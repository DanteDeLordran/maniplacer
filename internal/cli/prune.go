package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/dantedelordran/maniplacer/internal/utils"
	"github.com/spf13/cobra"
)

var pruneCmd = &cobra.Command{
	Use:   "prune",
	Short: "Removes every created manifest given a namespace",
	Long: `The prune command removes all manifests generated by Maniplacer 
inside the specified namespace. By default, it will target the "default" 
namespace unless another namespace is provided with the --namespace (-n) flag.

This command first validates that you are inside a valid Maniplacer project. 
It will then check if the manifests directory exists and contains files. 
If manifests are found, you will be asked for confirmation before deletion 
to prevent accidental data loss.

Typical usage includes cleaning up old or unused manifests when you want 
to reset your environment, free up space, or ensure that only fresh manifests 
are present for deployment.

Example:
  maniplacer prune --namespace staging

This will delete all manifests under the 'staging' namespace if confirmed.`,
	Args: cobra.MaximumNArgs(0),
	Run: func(cmd *cobra.Command, args []string) {

		if !utils.IsValidProject() {
			fmt.Printf("Current directory is not a valid Maniplacer project\n")
			os.Exit(1)
		}

		confirmed := utils.ConfirmMessage("Confirm from deleting manifests?")

		namespace, err := cmd.Flags().GetString("namespace")
		if err != nil {
			fmt.Printf("Could not parse namespace flag, using default\n")
			namespace = "default"
		}

		repo, err := cmd.Flags().GetString("repo")
		if err != nil {
			fmt.Printf("Could not get repo flag due to %s\n", err)
			os.Exit(1)
		}

		currentDir, err := os.Getwd()
		if err != nil {
			fmt.Printf("Could not get current dir due to %s\n", err)
			os.Exit(1)
		}

		currentDir = filepath.Join(currentDir, repo, "manifests", namespace)

		_, err = os.Stat(currentDir)
		if err != nil {
			fmt.Printf("Manifest dir does not exists %s\n", err)
			os.Exit(1)
		}

		files, err := os.ReadDir(currentDir)
		if err != nil {
			fmt.Printf("Could not read manifests dir due to %s\n", err)
			os.Exit(1)
		}

		if len(files) == 0 {
			fmt.Printf("No manifests on %s namespace\n", namespace)
			return
		}

		if !confirmed {
			fmt.Printf("No manifest will be deleted :P\n")
		} else {
			fmt.Printf("Deleting manifests in %s namespace...\n", namespace)
			for _, file := range files {
				err = os.RemoveAll(filepath.Join(currentDir, file.Name()))
				if err != nil {
					fmt.Printf("Could not delete %s due to %s, skipping...\n", file.Name(), err)
					continue
				}
				fmt.Printf("Successfully deleted %s\n", file.Name())
			}
		}

	},
}

func init() {
	rootCmd.AddCommand(pruneCmd)
	pruneCmd.Flags().StringP("namespace", "n", "default", "Namespace for pruning manifests")
	pruneCmd.Flags().StringP("repo", "r", "", "Repo name")
}
